# 지속 가능한 코드

올해있었던 일이다. 얼마 전 트위터 타임라인을 보다가 네이버 카페의 어떤 기능에 대해 불평하는 글을 보았다.
보셨을 수도 있는데, 블로그나 카페 글을 드래그 해서 선택한 후 복사하면 출처가 자동으로 삽입되는 기능이다.
호기심에 해당 코드를 다시 살펴보다가 깜짝 놀랐다.
무려 2008년에 내가 작성했던 코드가 토씨 하나 변하지 않은 채 그대로 사용되고 있었기 때문이다.
2008년이면 한창 Ajax라는 말이 떴던 시기. 어째서 그 오랜 코드가 아직까지 사용될 수 있었을까 생각해봤음

일단 기능이 단순했고 의존성이 적어서 JS 업계에서 몇 번의 변혁이 있은 뒤에도 살아남을 수 있었다 결론 내림.
특히 큰 기업에서는 잘 동작하면 어지간하면 건드리지 않음. 그거 아니라도 할 일이 많기도 하고 잘 모르는 업무에 손댔다가 알고보니 다른 부서에서 사용하고 있더라 이렇게 되면 뒷감당하기가 어려울 수도 있거든.

## 좋은 코드

좋은 코드라는 말 자체가 굉장히 모호하다.
어디까지나 내 의견. 일부는 동의하는 사람도 있을테고 또 일부엔 동의하지 않는 사람도 있을 것.

1. 사람이 읽기 좋아야 함

2. 간결하고 의도가 명확해야 함. 주석으로 보조하는 건 괜찮지만 가능하다면 코드 만으로도 의도가 충분히 드러니도록 작성.
유명한 개발자이자 "리팩토링"이라는 책의 저자인 마틴 파울러는 이런 말을 남겼음. "사람이 이해할 수 있는 코드는 바보라도 작성할 수 있다. 좋은 프로그래머는 사람이 이해할 수 있는 코드를 작성한다". 여담이지만 리팩토링 이 책 괜찮음. 1판은 코드가 자바 기반이었는데 올해 번역서가 나온 2판은 자바스크립트 기반으로 되어있어 프론트엔드 개발자가 더 환영할만함.

2009년 PHP를 개발한 Rasmus의 강의를 직접 들은 적이 있음. 가장 강조했던 건 단순성(Simplicity). 복잡성이 증가하면 확장성(Scalability), 성능(Performance), 보안(Security) 등에 문제를 초래할 수 있다고 함.

3. 가능하면 의존성이 적은 코드. 극단적으로 없애라는 의미는 아님. 과도한 의존성을 경계하자는 거지. JS는 노드와 npm이 나타난 이후 다른 사람 코드를 가져다쓰기 너무 좋게 되어있음. 때로는 고민하지 않고 쓰기도 하는 것 같음. 2016년 발생한 leftpad 사건이 있음. 문자열의 길이가 주어진 숫자보다 작으면 공백 또는 전달한 문자를 채워넣어서 길이를 맞춰주는 모듈. 코드를 보면 알겠지만 엄청 짧음. https://github.com/left-pad/left-pad/blob/master/index.js
그런데 개발자가 모종의 사건때문에 자신이 올린 프로젝트를 다 지웠는데 그 중 leftpad가 있었음, 거기에 의존하는 다른 수많은 모듈도 작동이 멈춰버림. npm에 대해 다시 생각해보는 계기가 되었음. 자세한 내용은 블로터의 ["11줄의 코드, 인터넷을 패닉에 빠뜨리다"](http://www.bloter.net/archives/253447) 기사 읽어보길 바람

4. 하나의 함수, 메소드, 클래스는 각각 명확한 하나의 책임만 지니도록 함. 접속사없이 한 문장으로 설명할 수 없으면 다시 고민해보자. 12년 전에 작성한 코드가 어떻게 아직까지 살아있었겠나.

순환 복잡도(CC, Cyclomatic Complextity)라는 개념이 있음.
코드가 얼마나 복잡한지 측정하는 방법인데 코드 경로의 수를 더해서 복잡도 측정.
아주 간단히 말하면 분기가 발생하는 조건문, 반복문이 많아질 수록 복잡도 증가.
complexity-report라는 도구가 있긴 한데, 굳이 측정할 필요는 없다고 생각

<!--
function a(x) {
    if (true) {
        return x; // 1st path
    } else if (false) {
        return x+1; // 2nd path
    }

    return 4; // 3rd path
}
-->

## 디버깅

일반적인 디버깅의 단계(어디에서 말해야 좋을까)
1. 정상 시스템의 동작, 그러니까 기대하는 동작을 정의한다.
2. 원인을 섣불리 추측하지 않고, 일단은 "모른다"고 생각하고 출발한다.
3. 근본적인 원인을 알 때까지 최대한 많은 데이터를 모으며 현상을 관찰한다.
4. 증상이 아닌 원인을 수정한다.

이걸 프론트엔드 개발의 관점에서 설명하자면 나는 버그를 정의할 때는 크게 세 가지가 필요하다고 생각한다.

1. 재현 과정 - 내가 어떻게 했는데 잘 안되더라. 백엔드라면 아마 로그를 보고 어떤 데이터가 들어왔는지 그리고 어떤 데이터가 출력이 됐는지 주로 보겠지만 프론트엔드는 조금 다르다. 브라우저를 리로드하든 버튼을 클릭하든 어떤 식으로든 사용자의 액션이 있어야 발생하는 버그가 대부분. 게다가 버그가 발생하는 플랫폼은 사용자의 환경이다. 시스템마다 미묘하게 발생하는 차이가 버그를 만들 수도 있으므로 정확한 재현 과정이 필요하다. 사용자가 웹 브라우저에 설치한 확장 기능때문에 버그가 발생할 수도 있고, 사용자의 인터넷 환경이 느리거나 불안정해서 문제가 생길 수도 있다.

2. 기대 동작. 아까 말한 "정상 시스템의 동작"과 같은 부분이다. 왜 이것을 에러라고 인식했는가가 중요하다. 주문 버튼을 클릭했는데 주문 완료까지 3초가 걸렸다. 이건 에러일 수도 있고 아닐 수도 있다. 에러가 되려면 "결제는 1초 안에 완료되어야 한다"는 기대 동작이 있어야 한다. "한국어 입력에 문제가 있다"는 아무런 도움도 안되는 버그 보고. "'패스트캠퍼스'를 입력했는데 캠 부분의 받침이 분리되어야 캐ㅁ으로 된다"라고 정확한 기대 동작이 있어야 유의미한 버그로 존재할 수 있다.

3. 에러 메시지
브라우저 콘솔에 에러 메시지가 나타나는 버그는 상대적으로 원인을 발견하기 쉬운 편이다. 물론 어디까지나 상대적이라는 얘기다. 

에러가 나타나는 버그 중 경험상 가장 많이 본 건 오타. 변수나 함수 이름을 잘못 쓰는 경우. 컴파일을 하지 않는 JS는 실행해보기 전에는 에러를 알 수 없는 언어라서 이런 에러를 흔하게 만날 수 있음. 웹 서비스를 사용하다보면 텍스트가 나와야 할 부분에 undefined라고 써있는 사이트를 가끔 볼 수 있는데, 변수나 프로퍼티의 값이 설정되지 않은 상태에서 문자열로 출력하면 저렇게 나온다.

실행하지 않고 코드를 분석해 문제점을 찾아내는 것을 정적 분석이라고 하는데 타입스크립트가 정적 분석을 지원한다. 자바스크립트의 유연함을 조금 희생해서 변수나 함수를 선언할 때 타입을 선언해야 하는 대신 선언하지 않은 값을 사용하거나 맞지 않는 값을 할당 또는 전달했을 때 문제를 실행하기 전에 알려줌. 혹은 페이스북에서 만든 Flow처럼 자바스크립트에 타입 선언 확장 문법만 추가하는 도구도 있음. 현재는 TypeScript 쪽이 더 우세한 상황.

요즘 브라우저나 프레임워크는 에러 메시지를 굉장히 친절하게 보여주는 편이고 이걸로 검색하면 어지간한 문제는 다 확인할 수 있을 정도다. 그런데 특이하게도 초보들은 높은 비율로 에러 메시지를 읽지 않고 질문부터 한다. 그리고는 디버깅에 가장 중요한 에러 메시지는 쏙 빼고, "버튼을 클릭했는데 아무 동작도 안하네요. 왜 그럴까요?" 같은 질문을 한다. 주니어가 시니어로 가려면 에러 메시지를 잘 읽고 해석할 수 있어야 한다. 해석이라는 건 영어 메시지를 한국어로 번역하라는 의미가 아니라, 그 메시지가 내포하고 있는 의미까지 알아야 한다는 뜻이다.


에러 메시지가 나타나지 않는 문제라면 조금 더 복잡해진다. 백엔드와 다르게 프론트엔드에는 보통 개발용 로그를 수집하지 않는다. 수많은 사용자의 로그를 다 보관하는 게 사실상 불가능할 뿐더러 비효율적이고 자칫하면 프라이버시 관련해서 법적인 문제가 될 수도 있다. 이럴 때는 결국 역순으로 찾아가는 수 밖에 없다. 버튼을 클릭하면 안내 메시지가 나타났어야 하는데 나타나지 않는다면 버튼을 클릭하는 순간부터 안내 메시지를 표시하는 순간까지 존재하는 모든 과정을 다 점검해봐야 한다.

다행히 웹 브라우저 디버거의 발전 덕분에 프로세스를 점검할 수는 있게 되었지만 이 케이스의 버그는 원인을 찾기도 어렵고 보통 해결도 어렵다. 

## 테스트

이런 말이 있다. 정확하게는 기억이 안나지만 대충 이런 맥락이었다.
"당신이 만든 프로그램의 사용자는 두 부류다. 13살에 이미 국방부와 CIA를 해킹한 천재 해커와 버튼이 어디있는지 못 찾는 바보"
방어적으로 프로그래밍을 해야하고 극단적인 상황도 가정해야 하는 이유.

작성한 코드가 의도한 대로 동작하는지 확인하는 자동화되고 표준적인 방법. 시스템에 관한 지식을 전달하는 것에 목적이 있다. 따라서 좋은 테스트란 시스템에 관해 필요한 지식을 빠짐없이 전달할 수 있어야 한다. 이 때문에 테스트 커버리지를 중요한 수치로 여기는 개발팀도 있지만 개인적으로 좋은 테스트를 결정하는 건 얼마나 "많은 양의 코드"를 테스트했느냐가 아니다. 테스트 커버리지는 단순히 어떤 결과를 내기 위해 실행된 코드의 양을 측정할 뿐. 해당 코드에 관한 단언문이 없다면 테스트를 하지 않은 것으로 봐야한다는 시각도 있다. 

어떤 라이브러리가 있는데 공식 문서를 봐도 어떻게 사용하는지 잘 모르겠다면 관련 테스트 코드를 보라.
어떤 동작을 의도했는지 어떤 걸 에지 케이스(edge case)로 상정하고 있는지 알 수 있다.
엣지 케이스는 경계 케이스(boundary case)라고도 부르는데 주어진 조건이 극한의 상황일 때 발생하는 문제를 말한다.
쉽게 말하면 일부러 테스트가 실패할 법한 값을 넣어서 테스트를 진행해보는 것이다.
예를 들어 두 숫자를 더해주는 간단한 함수가 있다고 하자. 처음 테스트는 아마 다음과 같이 할 것이다.

```
expect(add(1, 6)).toBe(7);
```

그런데 함수는 정수만 다룬다고 정의해두었다고 생각해보자. 그러면 일부러 소숫점이 있는 값을 넣어본다.

```
expect(add(1.2, 6)).toBe(7);
```

소숫점을 정수로 변환하기는 했는데 반올림을 해야할까, 아니면 버림을 해야할까? 함수의 정의에 따라 이 부분도 테스트해야 한다.

```
expect(add(1.5, 6)).toBe(8);
```

일부러 반올림이 되는 끝자락에 있는 1.5와 같은 값을 넣어서 테스트 해본다.
숫자를 다루는 값인데 숫자가 아닌 값을 넣으면 어떻게 될까. 자바스크립트에서 정수가 표현할 수 있는 최고 숫자 혹은 최소 숫자를 넣으면 결과가 어떻게 변할까? 이런 식으로 극한의 값을 테스트하여 엣지 케이스를 방지할 수 있다.


좋은 테스트의 조건
1. 실행 속도가 빨라야 함. 
2. 내부 구현(테스트하지 않는 부분)을 변경했다고 해서 깨지면 안됨. 인터페이스(입출력 위주)를 중심으로 작성. 비공개 메스드도 테스트를 해야하는가라는 논쟁을 가끔 볼 수 있는데 테스트의 목적이 모든 코드를 테스트하자는 게 아니라 공용 인터페이스가 작동하도록 보장하는 데 있음을 명심.
3. 버그를 찾을 수 있어야 한다. 만들었다고 끝이 아님 테스트 시나리오를 잘 설정해야 함.
4. 테스트 결과에 일관성이 있어야 함. 코드는 안 변했는데 실행할 때마다 테스트 결과가 달라지면 어쩔 거임. 그런데 그런 일도 생기긴 함. 우리 회사 CI의 E2E 테스트
5. 의도가 명확히 드러나야 함.

## 코드 커버리지

보통 라인 수 기준으로 측정. 70%만 넘어도 훌륭한 수준.
100%는 불가능. 억지로 100%로 맞추려고 어거지 코드를 작성하거나 중요한 로직이 없는 단순한 코드까지도 모두 테스트하는 건 오히려 시간 낭비.
특히 프론트엔드 개발에서는 사용자의 입력 등으로 해결해야 하는 부분이 많아 더 어려운 면이 있음.
E2E 테스트로 보완이 가능하긴 한데 완벽하게 된다는 뜻은 아님.
일단 브라우저 구동하고 사용자의 행동을 에뮬레이션하는 게 느림. 파일 드래그처럼 구현이 어려운 동작도 있음.

## TDD, BDD

테스트를 먼저 작성하고 그 후 실제 코드를 작성하는 방법. BDD가 사용자 시나리오에 조금 더 집중하는 면이 있지만 비슷.

아마 개발자로 일하다보면 수시로 마주치게 될 유명 개발자인 켄트 백(Kent Beck)이 개발 혹은 널리 알린 개념. "재발견"이라고 하는 건 켄트 백 본인이 아주 오래된 책에서 봤다고 말하고 있어서. 천공 테이프로 개발하던 시절의 책이라고.

장점
1. 테스트를 먼저 작성하기 때문에 전체 코드에서 얼마나 많은 코드가 테스트되는가를 측정하는 테스트 커버리지 비율이 자연스럽게 높아진다.
2. 테스트 되는 것만 코드로 작성하므로 코드가 방대해지지 않는다.
3. 버그때문에 발생하는 시간 낭비 줄여주고, 코드가 원하는 바를 명확히 달성하는지 쉽게 확인

방법
1. 테스트를 먼저 작성한다. 만족하는 코드가 없는 상태이므로 당연히 테스트는 실패함.
2. 테스트를 통과하는 코드를 작성한다.
3. 리팩터링: 중복이 보이거나 더 개선할 방법이 있다면 코드를 개선한다.

3대 원칙 - 로버트 C. 마틴 (밥 아저씨, 클린 코더)
1. 실패할 테스트를 작성하기 전에는 아무런 프로덕션 코드도 작성하지 않는다.
2. 실패할 테스트 말고는 작성하지 않는다.
3. 현재 실패한 테스트를 만족시키는 코드 외에는 작성하지 않는다.

ODA 원칙 - 맥스 카넷-알렉산더(구글의 Code Health 기술 책임자)는 저서 "심플 소프트웨어"에서 말한 TDD는 물론 모든 소프트웨어 개발에 적용될 수 있을만한 원칙 Observation, Descision, Action "결정하고 실행하기 전에 관찰부터 해라" 어찌 들으면 너무 당연한 말.

1주기 - 문제를 "관찰"하고, 해결할 지 어떨지 "결정"하고 테스트를 작성한다(실행).
2주기 - 테스트를 보고 API가 괜찮은지 관찰하고, 괜찮지 않으면 수정 방법을 결정하고, 테스트를 수정(실행). API가 괜찮아 보일 때까지 반복.
3주기 - API가 괜찮으면 테스트를 실행하고 통과하는 지 본다. [실패하겠지] (관찰), 테스트를 어떻게 통과할 지 방법을 정한다 [코드 구현에 대한 설계] (결정), 코드를 작성한다. (실행)
4주기 - 테스트를 실행해서 작성한 코드가 테스트를 통과하는지 본다. (관찰), 통과하지 못하면 코드를 어떻게 수정할 지 결정한다. 코드를 작성한다 (실행) - 반복

TDD 실습 
369게임 - 숫자 배열을 넣으면 369게임 규칙에 따라 숫자를 읽는 문자열을 반환하는 프로그램.
ex) game([1, 2, 3]) => '일,이,짝'

- 1. [1, 2]만 넣어서 숫자를 읽는지 테스트 오류) 3/6/9에서는 짝
- 2. 3이 들어가면 짝으로 나오는지 테스트. 오류) 두 자릿수라면 두 숫자 다 확인해야함
- 33이 나오면 두 번 짝짝하는지 테스트. 최종적으로 세 자리도 테스트

단점
적어도 제가 지금까지 일하면서 TDD를 제대로 진행하는 곳을 못 봤음.
처음엔 어느 정도 지켜지다가도 시간이 지나고 업무가 바쁘면 우선 순위가 밀리기도 함.

## 리팩터링

리팩터링의 의미는 조금씩 다르게 사용되는데, 유명한 개발자 마틴 파울러는 리팩터링을 이렇게 정의했다.

```
소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 마틴 파울러, 리팩터링 2판, 한빛미디어
```

겉보기 동작은 그대로 유지한다는 거 중요!

리팩터링은 언제?
내가 가진 원칙과 굉장히 비슷.
리팩터링과 관련된 건 아니고 3번 비슷한 일을 반복하게 되면 자동화가 필요할 때라고 말하곤 했는데 리팩터링에서도 비슷한 원칙을 발견함.
"3의 법칙"
```
돈 로버츠
1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 한다면(중복이 생겨 당황스럽겠지만) 그래도 일단은 그냥 진행한다.
3. 비슷한 일을 세 번째 하면 리팩터링한다.
```

리팩터링 대상? - 상세한 내용은 [리팩터링 2판, 한빛미디어]에서 확인. 여기선 자주 봤던 것만 추려봄
나쁜 코드에서는 악취가 난다고 하고 이를 Code Smell이라고 부름. 켄트 백과 마틴 파울러가 90년대 사용해서 유명해진 용어.
1. 너무 큰 함수나 클래스
2. 이름이 명확하지 않은 함수나 변수 이름. 지나치게 짧은 것보다는 조금 긴 게 나음. 개인 프로젝트거나 구성원 간 협의만 있으면 차라리 한국어로 작성해도 좋다고 생각. 어차피 번들러와 미니파이어가 다른 이름으로 바꿀 거거든.
3. 중복 코드: 같은 일을 하는 코드가 여기저기 산재해있으면 수정
4. 전역 변수: 가능하면 함수 내 혹은 모듈 내에 두자
5. 과도한 콜백. 조건문 중첩
6. 과도하게 긴 식별자

리팩터링 하기 전에 테스트 케이스부터 작성하자.
현실에선 테스트 케이스없는 코드를 만나기가 더 쉬움.
리팩토링하면서는 코드 작성에 집중하느라 테스트를 해피 패스만 해보고 말기도 함. 때로는 노룩 리팩토링을 하기도
동료와 리팩터링에 관해 말하면서 서로 격하게 동의했던 부분이 이거였다. 테스트없는 리팩터링은 끔찍하다.
최소한의 안전 장치는 있어야 하지 않겠나

리팩토링 방법 몇 가지
1. 함수 추출 혹은 옯기기: 로직을 별도의 함수나 모듈로 분리
```
function processPosts() {
    const posts = getPosts();
    ...
    posts.forEach(post => {
        console.log(post);
    });
    ...
}

to

function logPosts(posts) {
    posts.forEach(post => {
        console.log(post);
    });
}

function processPosts() {
    const posts = getPosts();
    ...
    logPosts(posts);
    ...
}
```
2. 중간 변수 도입: 어떤 값인지 설명하는 중간 변수 도입. 아까 말했듯 이름 조금 길어도 괜찮아.
```
const user = getUser();
if (user.authKey) {
    ...
}

to

const user = getUser();
const isLoggedIn = Boolean(user.authKey);

if (isLoggedIn) {
    ...
}
```
조금 복잡한 계산이 필요하다면 함수로 만드는 방법도 있음
```
const user = getUser();
const purchases = getPurchaseHistory(user);

// 지금까지 구매 내역이 없는 한국어 사용자에게 이벤트 배너 표시
if (user.authKey && user.locale === 'kr' && purchases.length === 0) {
    showEventBanner();
}

to

function isEligibleForEvent(user) {
    const purchases = getPurchaseHistory(user);
    const isLoggedIn = Boolean(user.authKey);
    const isKoreanUser = user.locale === 'kr';
    const hasPurchaseHistory = purchases.length > 0;

    return ( isLoggedIn && isKoreanUser && ! hasPurchaseHistory );
}


const user = getUser();
if (isEligibleForEvent(user)) {
    showEventBanner();
}
```

3. var가 보이거든 let, const로 변환. let 보다는 const 위주로 사용. let이 보인다면 꼭 필요한 것인지 다시 한 번 고려.

4. 함수의 사이드 이펙트 최소화. 가능하면 순수 함수로 작성하자.

5. 조건식 통합: 책에서는 '조건식 통합'이랬지만 차라리 분리하고 함수로 나누는 방법을 오히려 추천. 코드가 더 명확함. 그렇지 않다면 변수 이름으로 받아서 작성하는 방법도 있음. 들여쓰기와 괄호 중괄호 조합때문에 오히려 지저분하게 느껴지기도 해서...

6. 빠른 실패: fast fail. 들여쓰기 단계를 줄여줌

7. 반복문 보다는 파이프: 이해하기 쉬워서.
<~--
const names = [];
for (const i of input) {
    if (i.job === 'programmer') {
        names.push(i.name);
    }
}

const names = input.filter(i => i.jpb === 'programmer').map(i => i.name);

// 비슷한 사례
const items = [1, 2, 3];
for (let i = 0; i < items.length; i++) {
    let item = items[i];
    console.log(item);
}

[1, 2, 3].forEach( item => {
    console.log(item);
} );
-->
굳이 따지자면 성능면에서는 손해인데 막 수만건씩 다루는 게 아닌 이상 없다고 봐야 할 정도이므로 걱정하지 말고 쓰세요.

8. 조건, 반복문에 중괄호는 꼭 쓰는 편. 한 줄에 표현할 정도로 짧고 명확하면 생략하기도 함.

9. switch 대신 object literal

10. 배열이나 객체는 불변 객체처럼 Immutable하게 다루자. 변화가 추적되지 않아서 문제가 많이 생기는 부분이거든.
```
const blackPink = [ '지수', '제니', '로제', '리사' ];
blackPink.forEach((value, index) => {
    blackPink[index] += '❤️';
});
console.log(blackPink);

to 

const blackPink = [ '지수', '제니', '로제', '리사' ];
const blackPinkWithLove = blackPink.map((value, index) => {
    blackPink[index] += '❤️';
});
console.log(blackPinkWithLove);
```
함수에 전달된 파라미터도 마찬가지. 앞서 순수 함수처럼 작성하자는 것과도 같은 맥락.

11. 문자열 합치기 보다는 ES6 템플릿 문자열

## 마치며

